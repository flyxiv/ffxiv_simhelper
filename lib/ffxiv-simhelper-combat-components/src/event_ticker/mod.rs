use crate::event::ffxiv_event::FfxivEvent;
use crate::event::FfxivEventQueue;
use crate::live_objects::player::ffxiv_player::FfxivPlayer;
use crate::status::debuff_status::DebuffStatus;
use crate::types::{PlayerIdType, StatusTable};
use crate::types::{SkillIdType, TimeType};
use std::cell::RefCell;
use std::cmp::{max, Reverse};
use std::rc::Rc;

pub mod auto_attack_ticker;
pub mod ffxiv_event_ticker;
pub mod global_ticker;
pub mod independent_ticker;

pub static GLOBAL_TICK_INTERVAL_MILLISECOND: TimeType = 3000;
pub type PercentType = u16;

/// Tickers generate events based on combat's time rather than
/// the player's turn.
///
/// # Action
/// 1) Stores data needed for figuring out the time of the next event.
/// 2) Stores the events that are generated by the ticker at every tick.
///
/// # Flow
/// 1) The ticker doesn't insert its Event right away. It first generates and adds a tick event to the event queue, notifying that the ticker's next event will happen at that tick time.
/// 2) When the event queue reaches the tick event, the ticker is notified and
///    * first generates the next tick event and puts it in the event queue.
///    * then adds its events to the event queue.
pub trait EventTicker: Sized + Clone {
    /// this is executed when the Tick event of the EventTicker's id is reached.
    /// It first generates the next tick event and then adds its events to the event queue.
    fn run_ticker(
        &mut self,
        current_time_millisecond: TimeType,
        player: Option<Rc<RefCell<FfxivPlayer>>>,
        debuff: StatusTable<DebuffStatus>,
    ) {
        self.generate_tick_event(current_time_millisecond, player, debuff);
        self.add_next_event_to_queue(current_time_millisecond);
    }

    /// Generates the next tick event and adds it to the event queue.
    fn generate_tick_event(
        &mut self,
        current_time_millisecond: TimeType,
        player: Option<Rc<RefCell<FfxivPlayer>>>,
        debuff: StatusTable<DebuffStatus>,
    );

    /// Some tickers have a lifetime (ex) bard's song last for only 45 seconds). In this case, the ticker has to update the remaining time every time there is a change in current combat time.
    /// and delete itself when its remaining time is 0.
    fn update_remaining_time(&mut self, elapsed_time: TimeType);

    /// This is needed for skills like BRD's Empyreal Arrow, which forces the song to generate its event independent of the next tick time.
    /// Ran when ForceTick event is processed.
    /// Generate one copy of the ticker's events and add them to the event queue.
    fn force_tick(&self, current_time_millisecond: TimeType);

    /// Adds the ticker's event to the event queue.
    fn add_next_event_to_queue(&self, current_time_millisecond: TimeType) {
        self.get_event_queue()
            .borrow_mut()
            .push(Reverse(FfxivEvent::Tick(
                self.get_id(),
                max(current_time_millisecond + self.get_tick_interval(), 0),
            )));
    }

    fn get_event_queue(&self) -> Rc<RefCell<FfxivEventQueue>>;

    /// Gets the interval between one tick and the next.
    /// Server ticks will have a 3 second constant interval.
    /// Auto attack ticks can have a variable interval depending on the player's current speed buffs(riddle of wind).
    fn get_tick_interval(&self) -> TimeType;
    fn get_player_id(&self) -> Option<PlayerIdType>;
    fn get_id(&self) -> TickerKey;
    fn set_event_queue(&mut self, event_queue: Rc<RefCell<FfxivEventQueue>>);

    /// Some tickers like DOTs and BRD's songs don't tick at the instant the ticker is started(has_initial_tick is false), but some
    /// ticks like auto attacks generate their first event at the instant the ticker is started(has_initial_tick is true).
    fn has_initial_tick(&self) -> bool;
    fn get_remaining_time(&self) -> TimeType;
}

#[derive(Hash, Copy, Clone, Eq, PartialEq, Debug)]
pub struct TickerKey {
    pub ticker_id: SkillIdType,
    pub player_id: PlayerIdType,
}

impl TickerKey {
    pub fn new(ticker_id: SkillIdType, player_id: PlayerIdType) -> Self {
        Self {
            player_id,
            ticker_id,
        }
    }
}
